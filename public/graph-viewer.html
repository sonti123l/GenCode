<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Code Graph Visualizer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box
    }

    body {
      background: #111827;
      color: #fff;
      font-family: 'Segoe UI', system-ui, sans-serif;
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      user-select: none
    }

    /* ‚îÄ‚îÄ header ‚îÄ‚îÄ */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 20px;
      background: #1f2937;
      border-bottom: 1px solid #374151;
      flex-shrink: 0;
      gap: 12px
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .header-left h1 {
      font-size: 18px;
      font-weight: 700;
      letter-spacing: -.3px
    }

    .logo {
      width: 28px;
      height: 28px;
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center
    }

    .logo svg {
      width: 16px;
      height: 16px
    }

    /* ‚îÄ‚îÄ layout buttons ‚îÄ‚îÄ */
    .layout-bar {
      display: flex;
      gap: 4px;
      background: #374151;
      border-radius: 8px;
      padding: 3px
    }

    .layout-btn {
      background: transparent;
      border: none;
      color: #9ca3af;
      padding: 6px 14px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: background .15s, color .15s;
      display: flex;
      align-items: center;
      gap: 5px
    }

    .layout-btn:hover {
      background: #4b5563;
      color: #fff
    }

    .layout-btn.active {
      background: #2563eb;
      color: #fff
    }

    .layout-btn:disabled {
      opacity: .35;
      cursor: not-allowed
    }

    /* ‚îÄ‚îÄ zoom controls ‚îÄ‚îÄ */
    .zoom-bar {
      display: flex;
      gap: 4px
    }

    .zoom-btn {
      background: #374151;
      border: none;
      color: #fff;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background .15s
    }

    .zoom-btn:hover {
      background: #4b5563
    }

    .zoom-btn svg {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round
    }

    /* ‚îÄ‚îÄ body layout ‚îÄ‚îÄ */
    .body {
      display: flex;
      flex: 1;
      overflow: hidden
    }

    /* ‚îÄ‚îÄ canvas area ‚îÄ‚îÄ */
    .canvas-wrap {
      flex: 1;
      position: relative;
      background: #111827
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: grab
    }

    canvas.dragging {
      cursor: grabbing
    }

    /* ‚îÄ‚îÄ overlays ‚îÄ‚îÄ */
    .overlay {
      position: absolute;
      pointer-events: none
    }

    .stats-overlay {
      top: 12px;
      left: 12px;
      background: rgba(31, 41, 55, .9);
      backdrop-filter: blur(6px);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 13px;
      line-height: 1.7;
      color: #d1d5db
    }

    .stats-overlay .label {
      color: #6b7280;
      font-size: 11px;
      margin-top: 4px
    }

    .computing-badge {
      color: #facc15;
      font-size: 11px;
      margin-top: 2px;
      animation: pulse 1.4s infinite
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1
      }

      50% {
        opacity: .4
      }
    }

    .hint {
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(37, 99, 235, .88);
      backdrop-filter: blur(6px);
      border-radius: 8px;
      padding: 8px 18px;
      font-size: 13px;
      white-space: nowrap
    }

    /* ‚îÄ‚îÄ sidebar ‚îÄ‚îÄ */
    .sidebar {
      width: 280px;
      background: #1f2937;
      border-left: 1px solid #374151;
      overflow-y: auto;
      flex-shrink: 0
    }

    .sidebar-section {
      padding: 16px;
      border-bottom: 1px solid #374151
    }

    .sidebar-section h3 {
      font-size: 15px;
      font-weight: 600;
      margin-bottom: 10px
    }

    .sidebar-section h4 {
      font-size: 11px;
      text-transform: uppercase;
      color: #6b7280;
      letter-spacing: .5px;
      margin-bottom: 8px;
      margin-top: 12px
    }

    .sidebar-section h4:first-of-type {
      margin-top: 0
    }

    /* node detail */
    .node-detail-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      margin-bottom: 6px
    }

    .node-detail-row .lbl {
      color: #9ca3af
    }

    .node-color-dot {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      flex-shrink: 0
    }

    .node-path {
      font-family: 'Consolas', monospace;
      font-size: 11px;
      background: #111827;
      padding: 6px 8px;
      border-radius: 5px;
      word-break: break-all;
      color: #60a5fa;
      margin-top: 4px
    }

    /* connection pills */
    .conn-group-label {
      font-size: 11px;
      color: #9ca3af;
      margin-bottom: 6px;
      margin-top: 10px
    }

    .conn-pill {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 11px;
      background: rgba(17, 24, 39, .5);
      padding: 5px 8px;
      border-radius: 5px;
      margin-bottom: 3px
    }

    .conn-pill-left {
      display: flex;
      align-items: center;
      gap: 6px
    }

    .conn-pill-bar {
      width: 14px;
      height: 2px;
      border-radius: 1px
    }

    .clear-btn {
      margin-top: 12px;
      width: 100%;
      padding: 7px;
      background: #374151;
      border: none;
      color: #fff;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: background .15s
    }

    .clear-btn:hover {
      background: #4b5563
    }

    /* legend */
    .legend-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      margin-bottom: 5px
    }

    .legend-edge-line {
      width: 24px;
      height: 2px;
      border-radius: 1px
    }

    /* error state */
    .error-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      text-align: center;
      padding: 20px
    }

    .error-state h2 {
      color: #ef4444;
      margin-bottom: 10px
    }

    .error-state p {
      color: #9ca3af
    }

    /* scrollbar */
    .sidebar::-webkit-scrollbar {
      width: 6px
    }

    .sidebar::-webkit-scrollbar-track {
      background: transparent
    }

    .sidebar::-webkit-scrollbar-thumb {
      background: #374151;
      border-radius: 3px
    }
  </style>
</head>

<body>

  <div id="app">
    <!-- ‚îÄ‚îÄ HEADER ‚îÄ‚îÄ -->
    <div class="header">
      <div class="header-left">
        <div class="logo"><svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2">
            <circle cx="12" cy="12" r="3" />
            <path
              d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83" />
          </svg></div>
        <h1>Code Graph Visualizer</h1>
      </div>
      <div style="display:flex;align-items:center;gap:12px">
        <div class="layout-bar" id="layoutBar">
          <button class="layout-btn active" data-layout="force">Force</button>
          <button class="layout-btn" data-layout="hierarchical">Tree</button>
          <button class="layout-btn" data-layout="circular">Circular</button>
          <button class="layout-btn" data-layout="grid">Grid</button>
        </div>
        <div class="zoom-bar">
          <button class="zoom-btn" id="zoomIn" title="Zoom In"><svg>
              <line x1="12" y1="8" x2="12" y2="16" />
              <line x1="8" y1="12" x2="16" y2="12" />
              <circle cx="11" cy="11" r="5" />
              <line x1="15" y1="15" x2="20" y2="20" />
            </svg></button>
          <button class="zoom-btn" id="zoomOut" title="Zoom Out"><svg>
              <line x1="8" y1="12" x2="16" y2="12" />
              <circle cx="11" cy="11" r="5" />
              <line x1="15" y1="15" x2="20" y2="20" />
            </svg></button>
          <button class="zoom-btn" id="resetView" title="Reset View"><svg>
              <polyline points="15 3 21 3 21 9" />
              <polyline points="9 21 3 21 3 15" />
              <path d="M21 15v6h-6" />
              <path d="M3 9V3h6" />
              <line x1="21" y1="3" x2="14" y2="10" />
              <line x1="3" y1="21" x2="10" y2="14" />
            </svg></button>
        </div>
      </div>
    </div>

    <!-- ‚îÄ‚îÄ BODY ‚îÄ‚îÄ -->
    <div class="body">
      <div class="canvas-wrap" id="canvasWrap">
        <canvas id="canvas"></canvas>
        <div class="overlay stats-overlay" id="statsOverlay">
          <div>Zoom: <span id="zoomPct">100</span>%</div>
          <div>Nodes: <span id="nodeCount">0</span></div>
          <div>Edges: <span id="edgeCount">0</span></div>
          <div class="label">Layout: <span id="layoutLabel">force</span></div>
          <div id="computingBadge" class="computing-badge" style="display:none">‚è≥ Computing layout‚Ä¶</div>
        </div>
        <div class="overlay hint" id="hint">üí° Click on any node to highlight its connections</div>
      </div>
      <div class="sidebar" id="sidebar">
        <div id="nodeDetailSection" style="display:none" class="sidebar-section"></div>
        <div class="sidebar-section" id="legendSection">
          <h3>Legend</h3>
          <h4>Node Types</h4>
          <div id="legendNodes"></div>
          <h4>Edge Types</h4>
          <div id="legendEdges"></div>
          <div style="margin-top:18px;padding-top:12px;border-top:1px solid #374151">
            <h3>Controls</h3>
            <ul style="font-size:11px;color:#6b7280;list-style:none;line-height:2">
              <li>‚Ä¢ Click & drag to pan</li>
              <li>‚Ä¢ Mouse wheel to zoom</li>
              <li>‚Ä¢ Click a node to highlight connections</li>
              <li>‚Ä¢ Switch layouts using the toolbar</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="errorState" class="error-state" style="display:none">
    <h2>‚ö†Ô∏è Failed to Load Graph</h2>
    <p id="errorMessage">No graph data found</p>
  </div>

  <script type="module">
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CONFIG & CONSTANTS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const NODE_COLORS = {
      file: '#3B82F6',
      function: '#10B981',
      class: '#F59E0B',
      variable: '#8B5CF6',
      import: '#6B7280'
    };

    const EDGE_COLORS = {
      CONTAINS: '#4B5563',
      CALLS: '#3B82F6',
      IMPORTS_FROM: '#10B981',
      USES: '#F59E0B',
      DEFINES: '#8B5CF6',
      EXTENDS: '#EF4444',
      EXPORTS: '#EC4899'
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // LOAD DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const urlParams = new URLSearchParams(window.location.search);
    const storageKey = urlParams.get('key');
    const srcUrl = urlParams.get('src');
    const path = urlParams.get('path');
    let GRAPH = null;

    try {
      if (path && window.__TAURI__) {
        const content = await window.__TAURI__.fs.readTextFile(path);
        GRAPH = JSON.parse(content);
      } else if (window.GRAPH_DATA) {
        GRAPH = window.GRAPH_DATA;
      } else if (srcUrl) {
        // Fetch from URL (asset protocol)
        const resp = await fetch(srcUrl);
        if (!resp.ok) throw new Error(`Failed to load graph file: ${resp.statusText}`);
        GRAPH = await resp.json();
      } else if (storageKey) {
        // Fallback to localStorage
        const data = localStorage.getItem(storageKey);
        if (!data) throw new Error('Graph data expired or not found');
        GRAPH = JSON.parse(data);
        localStorage.removeItem(storageKey);
      } else {
        throw new Error('No data source provided (src or key)');
      }

      if (!GRAPH.nodes || !GRAPH.edges) throw new Error('Invalid graph structure');
    } catch (err) {
      console.error('Failed to load graph:', err);
      document.getElementById('app').style.display = 'none';
      document.getElementById('errorState').style.display = 'flex';
      document.getElementById('errorMessage').textContent = err.message;
      throw err;
    }

    console.log("Graph loaded", GRAPH);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let positions = {};
    let scale = 1;
    let offset = { x: 0, y: 0 };
    let selectedNode = null;
    let layoutType = 'force';
    let isComputing = false;
    let worker = null;

    let neighborsMap = new Map();
    let edgesByNode = new Map();
    let hlEdges = new Set();
    let hlNodes = new Set();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BUILD ADJACENCY (once)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function buildAdjacency() {
      GRAPH.nodes.forEach(n => {
        neighborsMap.set(n.id, new Set());
        edgesByNode.set(n.id, []);
      });
      GRAPH.edges.forEach((e, i) => {
        neighborsMap.get(e.from)?.add(e.to);
        neighborsMap.get(e.to)?.add(e.from);
        edgesByNode.get(e.from)?.push(i);
        edgesByNode.get(e.to)?.push(i);
      });
    })();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // WEB WORKER (inline blob)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const WORKER_SRC = `
function forceLayout(nodes, edges){
  const W=1600,H=1200,N=nodes.length;
  const x=new Float64Array(N), y=new Float64Array(N);
  const vx=new Float64Array(N), vy=new Float64Array(N);
  const idMap=new Map(); nodes.forEach((n,i)=>idMap.set(n.id,i));

  const r=Math.min(W,H)*.3;
  for(let i=0;i<N;i++){
    const a=(i/N)*6.2832;
    x[i]=W/2+Math.cos(a)*r+(Math.random()-.5)*60;
    y[i]=H/2+Math.sin(a)*r+(Math.random()-.5)*60;
  }

  const eFrom=[],eTo=[];
  edges.forEach(e=>{
    const f=idMap.get(e.from),t=idMap.get(e.to);
    if(f!==undefined&&t!==undefined){eFrom.push(f);eTo.push(t);}
  });
  const EC=eFrom.length;

  const CELL=130, GW=Math.ceil(W/CELL)+1, GH=Math.ceil(H/CELL)+1;
  function buildGrid(){
    const g=new Array(GW*GH);
    for(let i=0;i<g.length;i++) g[i]=[];
    for(let i=0;i<N;i++){
      const gx=Math.max(0,Math.min(GW-1,(x[i]/CELL)|0));
      const gy=Math.max(0,Math.min(GH-1,(y[i]/CELL)|0));
      g[gy*GW+gx].push(i);
    }
    return g;
  }

  const REP=4500, ATT=.009, OPT=140, CG=.0008, STEPS=100, DAMP=.74, MSPD=14;
  for(let s=0;s<STEPS;s++){
    const tmp=1-(s/STEPS);
    const grid=buildGrid();
    vx.fill(0); vy.fill(0);

    for(let i=0;i<N;i++){
      const gx=Math.max(0,Math.min(GW-1,(x[i]/CELL)|0));
      const gy=Math.max(0,Math.min(GH-1,(y[i]/CELL)|0));
      for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const nx=gx+dx,ny=gy+dy;
        if(nx<0||nx>=GW||ny<0||ny>=GH) continue;
        const cell=grid[ny*GW+nx];
        for(let ci=0;ci<cell.length;ci++){
          const j=cell[ci]; if(j<=i) continue;
          const ddx=x[i]-x[j], ddy=y[i]-y[j];
          const dsq=ddx*ddx+ddy*ddy+1, d=Math.sqrt(dsq);
          const f=(REP*tmp)/dsq;
          const fx=ddx/d*f, fy=ddy/d*f;
          vx[i]+=fx; vy[i]+=fy; vx[j]-=fx; vy[j]-=fy;
        }
      }
    }
    for(let e=0;e<EC;e++){
      const fi=eFrom[e],ti=eTo[e];
      const ddx=x[ti]-x[fi], ddy=y[ti]-y[fi];
      const d=Math.sqrt(ddx*ddx+ddy*ddy)+.1;
      const f=(d-OPT)*ATT;
      vx[fi]+=ddx*f; vy[fi]+=ddy*f; vx[ti]-=ddx*f; vy[ti]-=ddy*f;
    }
    for(let i=0;i<N;i++){
      vx[i]+=(W/2-x[i])*CG; vy[i]+=(H/2-y[i])*CG;
      vx[i]*=DAMP; vy[i]*=DAMP;
      const sp=Math.sqrt(vx[i]*vx[i]+vy[i]*vy[i]);
      if(sp>MSPD){vx[i]=vx[i]/sp*MSPD;vy[i]=vy[i]/sp*MSPD;}
      x[i]=Math.max(50,Math.min(W-50,x[i]+vx[i]));
      y[i]=Math.max(50,Math.min(H-50,y[i]+vy[i]));
    }
    if(s%20===0||s===STEPS-1){
      const p={};
      for(let i=0;i<N;i++) p[nodes[i].id]={x:x[i],y:y[i]};
      postMessage({type:'progress',positions:p,done:s===STEPS-1});
    }
  }
}

function hierarchical(nodes,edges){
  const W=1600,H=1200;
  const out=new Map(),inc=new Map();
  nodes.forEach(n=>{out.set(n.id,[]);inc.set(n.id,[]);});
  edges.forEach(e=>{out.get(e.from)?.push(e.to);inc.get(e.to)?.push(e.from);});
  let roots=nodes.filter(n=>inc.get(n.id).length===0);
  if(!roots.length&&nodes.length) roots.push(nodes[0]);
  const levels=new Map(), visited=new Set();
  const q=roots.map(n=>({id:n.id,lv:0}));
  let maxLv=0;
  while(q.length){
    const{id,lv}=q.shift();
    if(visited.has(id)) continue;
    visited.add(id); levels.set(id,lv);
    if(lv>maxLv) maxLv=lv;
    out.get(id)?.forEach(c=>{if(!visited.has(c)) q.push({id:c,lv:lv+1});});
  }
  nodes.forEach(n=>{if(!levels.has(n.id)) levels.set(n.id,maxLv+1);});
  const byLv=new Map();
  levels.forEach((lv,id)=>{if(!byLv.has(lv))byLv.set(lv,[]);byLv.get(lv).push(id);});
  const p={}, lH=H/(maxLv+2);
  byLv.forEach((ids,lv)=>{
    const lW=W/(ids.length+1);
    ids.forEach((id,i)=>{p[id]={x:lW*(i+1),y:lH*(lv+1)};});
  });
  postMessage({type:'done',positions:p});
}

function circular(nodes){
  const W=1600,H=1200,r=Math.min(W,H)*.4,p={};
  nodes.forEach((n,i)=>{
    const a=(i/nodes.length)*6.2832;
    p[n.id]={x:W/2+Math.cos(a)*r,y:H/2+Math.sin(a)*r};
  });
  postMessage({type:'done',positions:p});
}

function grid(nodes){
  const cols=Math.ceil(Math.sqrt(nodes.length)),rows=Math.ceil(nodes.length/cols);
  const cW=1600/(cols+1),cH=1200/(rows+1),p={};
  nodes.forEach((n,i)=>{p[n.id]={x:cW*((i%cols)+1),y:cH*(Math.floor(i/cols)+1)};});
  postMessage({type:'done',positions:p});
}

self.onmessage=function(e){
  const{type,nodes,edges}=e.data;
  if(type==='force') forceLayout(nodes,edges);
  else if(type==='hierarchical') hierarchical(nodes,edges);
  else if(type==='circular') circular(nodes);
  else if(type==='grid') grid(nodes);
};
`;

    function startLayout(type) {
      if (worker) { worker.terminate(); worker = null; }
      isComputing = true;
      setComputing(true);

      worker = new Worker(URL.createObjectURL(new Blob([WORKER_SRC], { type: 'application/javascript' })));
      worker.onmessage = function (e) {
        const msg = e.data;
        if (msg.type === 'progress' || msg.type === 'done') {
          positions = msg.positions;
          draw();
          if (msg.type === 'done') {
            isComputing = false;
            setComputing(false);
            worker.terminate();
            worker = null;
          }
        }
      };
      worker.onerror = function (err) {
        console.error('Worker error:', err);
        isComputing = false; setComputing(false);
        worker.terminate(); worker = null;
      };

      const nodes = GRAPH.nodes.map(n => ({ id: n.id, type: n.type }));
      const edges = GRAPH.edges.map(e => ({ from: e.from, to: e.to }));
      worker.postMessage({ type, nodes, edges });
    }

    function setComputing(val) {
      document.getElementById('computingBadge').style.display = val ? 'block' : 'none';
      document.querySelectorAll('.layout-btn').forEach(b => b.disabled = val);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SELECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function selectNode(node) {
      selectedNode = node;
      hlEdges.clear();
      hlNodes.clear();
      if (node) {
        hlNodes.add(node.id);
        neighborsMap.get(node.id)?.forEach(id => hlNodes.add(id));
        edgesByNode.get(node.id)?.forEach(idx => hlEdges.add(idx));
      }
      renderSidebar();
      document.getElementById('hint').style.display = node ? 'none' : 'block';
      draw();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // DRAW
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let canvasW = 0, canvasH = 0;

    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvasW = rect.width; canvasH = rect.height;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', () => { resizeCanvas(); draw(); });
    resizeCanvas();

    function draw() {
      ctx.clearRect(0, 0, canvasW, canvasH);
      ctx.save();
      ctx.translate(offset.x, offset.y);
      ctx.scale(scale, scale);

      const hasSel = selectedNode !== null;
      const edges = GRAPH.edges;
      const nodes = GRAPH.nodes;

      // ‚îÄ‚îÄ 1. Dimmed edges (when selection active) ‚îÄ‚îÄ
      if (hasSel) {
        ctx.save();
        ctx.globalAlpha = .1;
        ctx.strokeStyle = '#6B7280';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < edges.length; i++) {
          if (hlEdges.has(i)) continue;
          const fp = positions[edges[i].from], tp = positions[edges[i].to];
          if (!fp || !tp) continue;
          ctx.moveTo(fp.x, fp.y); ctx.lineTo(tp.x, tp.y);
        }
        ctx.stroke();
        ctx.restore();
      }

      // ‚îÄ‚îÄ 2. Active edges (batched by color) ‚îÄ‚îÄ
      const buckets = new Map();
      for (let i = 0; i < edges.length; i++) {
        if (hasSel && !hlEdges.has(i)) continue;
        const c = EDGE_COLORS[edges[i].type] || '#6B7280';
        if (!buckets.has(c)) buckets.set(c, []);
        buckets.get(c).push(i);
      }

      buckets.forEach((indices, color) => {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = hasSel ? 2.5 : 1.8;
        ctx.globalAlpha = hasSel ? 1 : .55;
        ctx.beginPath();
        for (const i of indices) {
          const e = edges[i];
          const fp = positions[e.from], tp = positions[e.to];
          if (!fp || !tp) continue;
          ctx.setLineDash(e.unresolved ? [7, 4] : []);
          ctx.moveTo(fp.x, fp.y); ctx.lineTo(tp.x, tp.y);
        }
        ctx.stroke();
        ctx.restore();

        for (const i of indices) {
          const e = edges[i];
          const fp = positions[e.from], tp = positions[e.to];
          if (!fp || !tp) continue;
          const ang = Math.atan2(tp.y - fp.y, tp.x - fp.x);
          const ax = tp.x - Math.cos(ang) * 23, ay = tp.y - Math.sin(ang) * 23;
          const as = hasSel ? 9 : 7;
          ctx.save();
          ctx.fillStyle = color;
          ctx.globalAlpha = hasSel ? 1 : .55;
          ctx.beginPath();
          ctx.moveTo(ax, ay);
          ctx.lineTo(ax - as * Math.cos(ang - 0.5236), ay - as * Math.sin(ang - 0.5236));
          ctx.lineTo(ax - as * Math.cos(ang + 0.5236), ay - as * Math.sin(ang + 0.5236));
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          if (hasSel && hlEdges.has(i)) {
            const mx = (fp.x + tp.x) / 2, my = (fp.y + tp.y) / 2;
            const pa = ang + 1.5708;
            const lx = mx + Math.cos(pa) * 13, ly = my + Math.sin(pa) * 13;
            ctx.save();
            ctx.font = 'bold 9.5px sans-serif';
            const tw = ctx.measureText(e.type).width;
            ctx.fillStyle = 'rgba(17,24,39,.93)';
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            var lx2 = lx - tw / 2 - 5, ly2 = ly - 8, lw = tw + 10, lh = 16, lr = 3;
            ctx.moveTo(lx2 + lr, ly2);
            ctx.lineTo(lx2 + lw - lr, ly2);
            ctx.quadraticCurveTo(lx2 + lw, ly2, lx2 + lw, ly2 + lr);
            ctx.lineTo(lx2 + lw, ly2 + lh - lr);
            ctx.quadraticCurveTo(lx2 + lw, ly2 + lh, lx2 + lw - lr, ly2 + lh);
            ctx.lineTo(lx2 + lr, ly2 + lh);
            ctx.quadraticCurveTo(lx2, ly2 + lh, lx2, ly2 + lh - lr);
            ctx.lineTo(lx2, ly2 + lr);
            ctx.quadraticCurveTo(lx2, ly2, lx2 + lr, ly2);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = color;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(e.type, lx, ly);
            ctx.restore();
          }
        }
      });

      // ‚îÄ‚îÄ 3. Nodes ‚îÄ‚îÄ
      if (hasSel) {
        ctx.save();
        ctx.globalAlpha = .13;
        for (let i = 0; i < nodes.length; i++) {
          const n = nodes[i]; if (hlNodes.has(n.id)) continue;
          const p = positions[n.id]; if (!p) continue;
          ctx.fillStyle = NODE_COLORS[n.type] || '#6B7280';
          ctx.beginPath(); ctx.arc(p.x, p.y, 18, 0, 6.2832); ctx.fill();
        }
        ctx.restore();
      }

      for (let i = 0; i < nodes.length; i++) {
        const n = nodes[i];
        if (hasSel && !hlNodes.has(n.id)) continue;
        if (n.id === (selectedNode && selectedNode.id)) continue;
        const p = positions[n.id]; if (!p) continue;
        const color = NODE_COLORS[n.type] || '#6B7280';
        const conn = hasSel && hlNodes.has(n.id);

        ctx.save();
        if (conn) { ctx.shadowColor = color; ctx.shadowBlur = 9; }
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(p.x, p.y, 18, 0, 6.2832); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = conn ? '#fff' : (color + 'AA');
        ctx.lineWidth = conn ? 2.2 : 1.4;
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(n.type.charAt(0).toUpperCase(), p.x, p.y);
        ctx.restore();

        ctx.save();
        ctx.fillStyle = '#fff'; ctx.font = '11px sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        const lbl = (n.name || (n.path && n.path.split(/[\\/\\\\]/).pop()) || String(n.id)).substring(0, 17);
        ctx.fillText(lbl, p.x, p.y + 22);
        ctx.restore();
      }

      if (selectedNode) {
        const p = positions[selectedNode.id];
        if (p) {
          const color = NODE_COLORS[selectedNode.type] || '#6B7280';
          ctx.save();
          ctx.shadowColor = color; ctx.shadowBlur = 16;
          ctx.fillStyle = color;
          ctx.beginPath(); ctx.arc(p.x, p.y, 22, 0, 6.2832); ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 3.5; ctx.stroke();
          ctx.strokeStyle = color; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(p.x, p.y, 28, 0, 6.2832); ctx.stroke();
          ctx.fillStyle = '#fff'; ctx.font = 'bold 14px sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText(selectedNode.type.charAt(0).toUpperCase(), p.x, p.y);
          ctx.restore();
          ctx.save();
          ctx.fillStyle = '#fff'; ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center'; ctx.textBaseline = 'top';
          const lbl = (selectedNode.name || (selectedNode.path && selectedNode.path.split(/[\\/\\\\]/).pop()) || String(selectedNode.id)).substring(0, 20);
          ctx.fillText(lbl, p.x, p.y + 27);
          ctx.restore();
        }
      }

      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INTERACTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let dragging = false, dragStart = { x: 0, y: 0 };

    function mouseToGraph(e) {
      const r = canvas.getBoundingClientRect();
      return { x: (e.clientX - r.left - offset.x) / scale, y: (e.clientY - r.top - offset.y) / scale };
    }

    canvas.addEventListener('mousedown', function (e) {
      e.preventDefault();
      const pos = mouseToGraph(e);
      let hit = null, best = 26;
      for (let i = 0; i < GRAPH.nodes.length; i++) {
        const n = GRAPH.nodes[i], p = positions[n.id];
        if (!p) continue;
        const d = Math.hypot(pos.x - p.x, pos.y - p.y);
        if (d < best) { best = d; hit = n; }
      }
      if (hit) {
        selectNode(selectedNode && selectedNode.id === hit.id ? null : hit);
      } else {
        selectNode(null);
        dragging = true;
        dragStart = { x: e.clientX - offset.x, y: e.clientY - offset.y };
        canvas.classList.add('dragging');
      }
    });

    canvas.addEventListener('mousemove', function (e) {
      if (!dragging) return;
      offset.x = e.clientX - dragStart.x;
      offset.y = e.clientY - dragStart.y;
      draw();
    });

    function endDrag() {
      dragging = false;
      canvas.classList.remove('dragging');
    }
    canvas.addEventListener('mouseup', endDrag);
    canvas.addEventListener('mouseleave', endDrag);

    canvas.addEventListener('wheel', function (e) {
      e.preventDefault();
      const factor = e.deltaY > 0 ? .9 : 1.1;
      const newScale = Math.max(.08, Math.min(6, scale * factor));
      const r = canvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      offset.x = mx - (mx - offset.x) * (newScale / scale);
      offset.y = my - (my - offset.y) * (newScale / scale);
      scale = newScale;
      document.getElementById('zoomPct').textContent = (scale * 100).toFixed(0);
      draw();
    }, { passive: false });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // TOOLBAR WIRING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.getElementById('layoutBar').addEventListener('click', function (e) {
      const btn = e.target.closest('.layout-btn');
      if (!btn || btn.disabled) return;
      layoutType = btn.dataset.layout;
      document.querySelectorAll('.layout-btn').forEach(b => b.classList.toggle('active', b === btn));
      document.getElementById('layoutLabel').textContent = layoutType;
      startLayout(layoutType);
    });

    document.getElementById('zoomIn').addEventListener('click', () => {
      scale = Math.min(6, scale * 1.25);
      document.getElementById('zoomPct').textContent = (scale * 100).toFixed(0);
      draw();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      scale = Math.max(.08, scale / 1.25);
      document.getElementById('zoomPct').textContent = (scale * 100).toFixed(0);
      draw();
    });

    document.getElementById('resetView').addEventListener('click', () => {
      scale = 1; offset = { x: 0, y: 0 };
      document.getElementById('zoomPct').textContent = '100';
      draw();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SIDEBAR
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function renderSidebar() {
      const sec = document.getElementById('nodeDetailSection');
      if (!selectedNode) { sec.style.display = 'none'; return; }
      sec.style.display = 'block';

      const n = selectedNode;
      const color = NODE_COLORS[n.type] || '#6B7280';

      const outEdges = [], inEdges = [];
      (edgesByNode.get(n.id) || []).forEach(idx => {
        const e = GRAPH.edges[idx];
        if (e.from === n.id) outEdges.push(e); else inEdges.push(e);
      });
      const outCounts = {}, inCounts = {};
      outEdges.forEach(e => { outCounts[e.type] = (outCounts[e.type] || 0) + 1; });
      inEdges.forEach(e => { inCounts[e.type] = (inCounts[e.type] || 0) + 1; });

      let html = '<h3 style="display:flex;justify-content:space-between;align-items:center">Selected Node</h3>';
      html += '<div class="node-detail-row"><div class="node-color-dot" style="background:' + color + '"></div><span class="lbl">Type:</span><span>' + n.type + '</span></div>';
      if (n.name) html += '<div class="node-detail-row"><span class="lbl">Name:</span><span style="word-break:break-all">' + escHtml(n.name) + '</span></div>';
      if (n.path) html += '<div class="node-detail-row"><span class="lbl">Path:</span></div><div class="node-path">' + escHtml(n.path) + '</div>';
      if (n.language) html += '<div class="node-detail-row"><span class="lbl">Language:</span><span>' + n.language + '</span></div>';
      if (n.lines) html += '<div class="node-detail-row"><span class="lbl">Lines:</span><span>' + n.lines + '</span></div>';

      html += '<div style="margin-top:14px;padding-top:12px;border-top:1px solid #374151"><h4 style="font-size:13px;font-weight:600;margin-bottom:8px">Connections</h4>';
      if (outEdges.length) {
        html += '<div class="conn-group-label">Outgoing (' + outEdges.length + ')</div>';
        Object.entries(outCounts).forEach(([type, cnt]) => {
          const c = EDGE_COLORS[type] || '#6B7280';
          html += '<div class="conn-pill"><div class="conn-pill-left"><div class="conn-pill-bar" style="background:' + c + '"></div><span>' + type + '</span></div><span style="color:#6b7280">' + cnt + '</span></div>';
        });
      }
      if (inEdges.length) {
        html += '<div class="conn-group-label">Incoming (' + inEdges.length + ')</div>';
        Object.entries(inCounts).forEach(([type, cnt]) => {
          const c = EDGE_COLORS[type] || '#6B7280';
          html += '<div class="conn-pill"><div class="conn-pill-left"><div class="conn-pill-bar" style="background:' + c + '"></div><span>' + type + '</span></div><span style="color:#6b7280">' + cnt + '</span></div>';
        });
      }
      html += '</div>';
      html += '<button class="clear-btn" onclick="selectNode(null)">Clear Selection</button>';

      sec.innerHTML = html;
    }

    function escHtml(s) { return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // LEGEND
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function renderLegend() {
      let h = '';
      Object.entries(NODE_COLORS).forEach(([t, c]) => {
        h += '<div class="legend-row"><div class="node-color-dot" style="background:' + c + '"></div><span style="text-transform:capitalize">' + t + '</span></div>';
      });
      document.getElementById('legendNodes').innerHTML = h;
      h = '';
      Object.entries(EDGE_COLORS).forEach(([t, c]) => {
        h += '<div class="legend-row"><div class="legend-edge-line" style="background:' + c + '"></div><span style="font-size:11px">' + t + '</span></div>';
      });
      document.getElementById('legendEdges').innerHTML = h;
    })();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    document.getElementById('nodeCount').textContent = GRAPH.nodes.length;
    document.getElementById('edgeCount').textContent = GRAPH.edges.length;
    startLayout('force');

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (worker) worker.terminate();
    });
  </script>
</body>

</html>